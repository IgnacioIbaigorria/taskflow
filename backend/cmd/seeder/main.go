package main

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"time"
)

const baseURL = "http://localhost:8080/api/v1"

type LoginRequest struct {
	Email    string `json:"email"`
	Password string `json:"password"`
}

type LoginResponse struct {
	Token string `json:"token"`
}

type CreateTaskRequest struct {
	Title       string `json:"title"`
	Description string `json:"description"`
	Priority    string `json:"priority"`
	DueDate     string `json:"due_date,omitempty"`
}

func main() {
	// 1. Login to get token
	token, err := login("admin@example.com", "admin123")
	if err != nil {
		fmt.Printf("Login failed (trying register next): %v\n", err)
		// Try to register if login fails (first run)
		err = register("admin@example.com", "admin123", "Admin User")
		if err != nil {
			fmt.Printf("Register failed: %v\n", err)
			return
		}
		token, err = login("admin@example.com", "admin123")
		if err != nil {
			fmt.Printf("Login after register failed: %v\n", err)
			return
		}
	}
	fmt.Println("Successfully logged in/registered")

	// 2. Create 25 tasks
	priorities := []string{"low", "medium", "high", "urgent"}
	for i := 1; i <= 25; i++ {
		priority := priorities[i%len(priorities)]
		dueDate := time.Now().Add(time.Duration(i*24) * time.Hour).Format(time.RFC3339)

		// Make some overdue
		if i%5 == 0 {
			dueDate = time.Now().Add(-time.Duration(24) * time.Hour).Format(time.RFC3339)
		}

		task := CreateTaskRequest{
			Title:       fmt.Sprintf("Task %d - Pagination Test", i),
			Description: fmt.Sprintf("Description for task %d generated by seeder.", i),
			Priority:    priority,
			DueDate:     dueDate,
		}

		err := createTask(token, task)
		if err != nil {
			fmt.Printf("Failed to create task %d: %v\n", i, err)
		} else {
			fmt.Printf("Created task %d\n", i)
		}
		time.Sleep(100 * time.Millisecond) // Be nice to the server
	}
	fmt.Println("Done seeding tasks!")
}

func login(email, password string) (string, error) {
	reqBody, _ := json.Marshal(LoginRequest{Email: email, Password: password})
	resp, err := http.Post(baseURL+"/auth/login", "application/json", bytes.NewBuffer(reqBody))
	if err != nil {
		return "", err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return "", fmt.Errorf("status code: %d", resp.StatusCode)
	}

	var loginResp LoginResponse
	if err := json.NewDecoder(resp.Body).Decode(&loginResp); err != nil {
		return "", err
	}
	return loginResp.Token, nil
}

func register(email, password, name string) error {
	reqBody, _ := json.Marshal(map[string]string{
		"email":    email,
		"password": password,
		"name":     name,
	})
	resp, err := http.Post(baseURL+"/auth/register", "application/json", bytes.NewBuffer(reqBody))
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 201 && resp.StatusCode != 200 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("status code: %d, body: %s", resp.StatusCode, string(body))
	}
	return nil
}

func createTask(token string, task CreateTaskRequest) error {
	reqBody, _ := json.Marshal(task)
	req, err := http.NewRequest("POST", baseURL+"/tasks", bytes.NewBuffer(reqBody))
	if err != nil {
		return err
	}

	req.Header.Set("Authorization", "Bearer "+token)
	req.Header.Set("Content-Type", "application/json")

	client := &http.Client{}
	resp, err := client.Do(req)
	if err != nil {
		return err
	}
	defer resp.Body.Close()

	if resp.StatusCode != 201 {
		body, _ := io.ReadAll(resp.Body)
		return fmt.Errorf("status code: %d, body: %s", resp.StatusCode, string(body))
	}
	return nil
}
